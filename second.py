# Новая глава изучения языка Python
# для того, чтобы вычислить одно число в степени другого числа (2014 в степени 14 2014^14):
count = 2014 ** 14  
print(count)
#всегда будут небольшие погрешности:
a = 0.3 + 0.3 + 0.3
print(a)
#результат : 0.8999999...

#Запишите число 1.2345e3 в виде десятичной дроби:
a = 1.2345e3
print(a)
#1234.5
# 1.2345e-3 (результат: 0.0012345)

a = 7/3
b = 7//3
print(a) #2.3333333333333335 (целое число с дробной его частью)
print(b) #2 (целое число без дробной части (округленное))

a = input('Введите Ваше сообщение:') #input: Введите Ваше сообщение: Hello, World!
print('Введенное сообщение:', a)                             #output: Hello, World!

#Функции и их применение:
abs(value) #отбрасывает знаки вокруг цифр( abs(-7) = 7 ; abs(5) = 5; abs(-5*4) = 20 ) (число по модулю)
min(x1, x2, x3 .... ) #находит наименьшее из представленных чисел ( min(3,1,5,7,9) = 1 )
max(x1, x2, x3, ....) #находит наибольшее из представленных чисел (max(3,1,6,8,2,9) = 9 )
pow(x,y) #возводит x в степень y ( pow(2,3) = 2**3 = 8 )
round(x) #округляет число ( round(3.5) = 4 ; round(3.4) = 3 )
         #( round(3.456, 2) = 3.46 ; round(3.456789, 4) = 3.4567 ) (второе число в скобках- сколько чисел нужно оставить после запятой)
         #( round(456, -1) = 460 (округление в сторону десятков с конца(56 ближе к 60)) ;
         # round(456, -2) = 500 (округление в разряде сотен (456 ближе к 500)) )
         # Разряд: -2 -1 0 1 2 3  #по указанному номеру идет округление
         # Число:   1  2 3,4 5 6   #единица относится к -2 разряду, двойка - к -1, тройка - к 0, четверка - к 1, и т.д.
type(x) #возвращает тип объекта ( type(4) = <class 'int'>; type('Victoria') = <class 'str'>; type(4.5) = <class 'float'> )
max(3,5,2,7,8,9,abs(-56)) = 56 #внутри функций можно использовать другие функции
9**0.5 = 3.0; pow(9, 0.5) = 3.0 #нахождение корня из числа
9**1/2 = 4.5 #поочередное действие: 9 возведение в 1, затем деление на 2
9**(1/2) = 3.0; pow(9, 1/2) = 3.0

    #Задание:  Катя узнала, что ей для сна надо X минут. В отличие от Коли, Катя ложится спать после полуночи в H часов и М минут. Помогите Кате определить, на какое время ей поставить будильник, чтобы он прозвенел ровно через X минут после того, как она ляжет спать. На стандартный ввод, каждое в своей строке, подаются значения X, H и M. Гарантируется, что Катя должна проснуться в тот же день, что и заснуть. Программа должна выводить время, на которое нужно поставить будильник: в первой строке часы, во второй — минуты.
#Put your python code here:

X = int(input('Необходимо для сна часов: '))
H = int(input('Во сколько ложишься спать часов: '))
M = int(input('Во сколько ложишься спать минут: '))
time = (H*60+M)+X
print('Необходимо проснуться в:', int(time//60), 'часов.') #9
print('Необходимо проснуться в:', int(time%60), 'минут.')  #2


#вычисляем, високосный ли год (от 1900 до 3000)
year = int(input('Введите год, чтобы узнать, високосный ли он: '))
if year%4==0 and year%100!=0 or year%400==0:
    print('Високосный.')
else:
    print('Не високосный.')

#функция '\n' позволяет переносить строку:
string = 'Up'
string_2 = 'Down'
print(string, '\n', string_2)
#, а:
'''
Так выглядит многострочный комментарий, начинающийся с трех кавычек и заканчивающийся ими.
Cтрок может быть сколько угодно.
Конец комментария.
'''
#вычисляем площадь треугольника, руководствуясь формулой Герона.
import math
a = int(input('Введите сторону а треугольника:'))
b = int(input('Введите сторону b треугольника:'))
c = int(input('Введите сторону c треугольника:'))
p = (a+b+c)/2 #формула вычесления полупериметра треугольника
S = p*(p-a)*(p-b)*(p-c) #формула вычесления площади треугольника
S = math.sqrt(S) #извлекаем квадратный корень получившейся площади
print('Площадь треугольника составляет:', float(S))


'''
Напишите программу, принимающую на вход целое число, которая выводит True, если переданное значение попадает в интервал (−15,12]∪(14,17)∪[19,+∞) и False в противном случае (регистр символов имеет значение).
'''
number = int(input('Введите на вход целое число. Если оно попадает в интервал, то выведется значение Истина: '))
if -15<a<=12 or 14<a<17 or a>=19:
    print('Истина' * True, 'Ложь' * False) #вместо print('True')  else: print('False') .
# (−15,12]∪(14,17)∪[19,+∞)


#В python есть такая структура данных: массивы(array). Они могут хранить данные лишь одного типа( либо числовые значения, либо только строки).
#Массив — упорядоченный набор элементов, каждый из которых хранит одно значение, идентифицируемое с помощью одного или нескольких индексов. В простейшем случае массив имеет постоянную длину и хранит единицы данных одного и того же типа, а в качестве индексов выступают целые числа. (wikipedia)
#посмотреть размерность массива - одномерный, двумерный и тд массив, можно :
   '''###''' Библиотека numpy:
#from numpy inport *
#a = array([2,3,4])

#a.ndim    #1
#размеры массива(число строк, столбцов и тд):
#a.shape  #(3,)

#создание двумерного массива из двух последовательностей чисел:
a = array([(1.5,2,3),(4,5.7,6)])    # [[1.5  2.  3.]
print(a)                            #   [4. 5.7  6.]]  #все элементы имеют один вид: число с плавающей точкой(вещественное число).
a.ndim  #2
a.shape #(2,3) (2 строки, 3 столбца)
a.size  #6 (общее количество элементов)

z = zeros((3,2)) #(3,2) помещаются в дополнительные скобки, чтобы представлять из себя один объект.
print(z)         # array([[0., 0.],
                 #        [0., 0.],
                 #        [0., 0.]])
#функция arange аналогична функции range, но возвращает массив:
arange (10, 30, 5)  # array([10, 15, 20, 25])

linspace(0,2,9) #генерирует 9 чисел от 0 до 2 с равным шагом
array([ 0. , 0.25 , 0.5 , 0.75 , 1. , 1.25 , 1.5 , 1.75 , 2.])

b = arange(12).reshape(4, 3) #reshape преобразует из одномерного- двумерный массив.
print(b)                      #[[ 0  1  2]
                              #[  3  4  5]
                              #[  6  7  8]
                              #[  9 10 11]]
                              
a = array([10, 20, 30])
b = arange(3)
print(a)  # [10, 20, 30]
print(b)  # [0, 1, 2]
#арифметические операции над массивами выполняются поэлементно:
#( нулевой элемент складывается/вычитается с нулевым элементом второго массива, первый элемент- с первым и тд )
print(a+b)  # [10, 21, 32]
print(a-b)  # [10, 19, 28]
# массивы так же можно возводить в квадрат:
print(a ** b)  # [1, 20, 900]

print(a)                                                    # [10, 20, 30]
2 * sin(a) #синус а, где а- это массив чисел [10, 20, 30]   # array ([ -1.08804222, 1.8258905, -1.97606325])

#операции сравнения в массивах:
a < 20  #будет применена к каждому элементу массива а. если в массиве 3 значения, то рез-т будет из трех логических значений
array([True, False, False], dtype=bool)
#dtype — объект, описывающий тип элементов массива. Можно определить dtype, используя стандартные типы данных Python. NumPy здесь предоставляет целый букет возможностей, например: bool, character, int, int8, int16, int32, int64, float, float8, float16, float32, float64, complex, complex64, object_.
  '''###'''
  
  """###""" Библиотека matplotlib:
from pylab import *
x = linspace(0, 5, 10)
y = x ** 2
print(x)
print(y) '''[0.         0.55555556 1.11111111 1.66666667 2.22222222 2.77777778
 3.33333333 3.88888889 4.44444444 5.        ]
[ 0.          0.30864198  1.2345679   2.77777778  4.9382716   7.71604938
 11.11111111 15.12345679 19.75308642 25.        ]'''
#рисуем график:
figure()
plot(x,y,'r') #'r'- 'red' - красными линиями рисовать график
xlabel('x')
ylabel('y')
title('title')
show()

#или:
fig = plt.figure()
axes = fig.add_axes([0.1, 0.1, 0.8, 0.8]) #'axes' - оси; ([left, bottom, width, height(range 0 to 1)])
axes.plot(x, y, 'r')
axes.set_xlabel('x')
axes.set_ylabel('y')
axes.set_title('title')

#построим два графика сразу на одной картинке:

fig = plt.figure()

axes1 = fig.add_axes([0.1, 0.1, 0.8, 0.8]]) #main axes(главные оси)
axes2 = fig.add_axes([0.2, 0.5, 0.4, 0.3]]) #insert axes
   #main figure
axes1.plot(x, y ,'r')
axes1.set_xlabel('x')
axes1.set_ylabel('y')
axes1.set_title('title')
   #insert
axes2.plot( y, x, 'g')
axes2.set_xlabel('y')
axes2.set_ylabel('x')
axes2.set_title('insert title')
show()

#построим два раздельных графика:
fig, axes = plt.subplots(nrows=1, ncols=2)

for ax in axes:
    ax.plot( x, y, 'r')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title('title');
    fig.tight_layout() #располагаем элементы, чтобы они не пересекались
# если не работает эта часть кода про раздельные графики, то:
from pylab import *
x = linspace(0, 5, 10)
y = x ** 2
fig, axes = plt.subplots(nrows=1, ncols=2)
for ax in axes:
    ax.plot(x, y, 'r')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title('title')
fig.tight_layout()
show()

#настроим размеры графика, например, вширь:
fig, axes = plt.subplots(figsize=(12,3))  #указываем размер фигуры(размер указывается в дюймах)
axes.plot(x,y,'r')
axes.set_xlabel('x')
axes.set_ylabel('y')
axes.set_title('title');

#изображаем два графика в одном c доп. легендой (легенда- это маленький квадратик, описывающий, что подразумевается под тем или иным цветом линий):
fig, ax = plt.subplots()

ax.plot( x, x**2, label='y = x**2') #что входит ->
ax.plot( x, x**3, label='y = x**3') #-> в легенду
ax.legend(loc=2); #upper left corner (размещаем легенду в левом верхнем углу)
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_title('title');

#Можно рисовать разными цветами. Чтобы убедиться вот например код, строящий три графика: квадратный (красный r), кубический (синий b) корни и корень двадцатой степени (зеленый g):
from pylab import *

x, y, z, a = [], [], [], []
for i in range(2000):
    x.append(i/1000)
    y.append((i/1000)**0.5)
    z.append((i/1000)**(1/3))
    a.append((i/1000)**(1/20))

figure()
plot (x, y, 'r')
plot (x, z, 'b')
plot (x, a, 'g')
show()
  """###"""
###
  #построение гистограмм! (histogram)
  
from numpy import *
n = random.randn(100000) #функция из numpy (генерирует 100000 случайных чисел)
fig, ages = plt.subplots( 1, 2, figsize=(12,4)) #1 строчка, 2 столбца, размер 12:4 в дюймах

axes[0].hist(n)
axes[0].set_title('Default histogram')
axes[0].set_xlim((min(n), max(n))) #минимальное и максимальное значение по осям

axes[1].hist(n, cumulative = True, bins = 50) # bins - кол-во вертикальных столбцов
axes[1].set_title('Cumulative detailed histogram') # Куммулятив - постепенно накапливающийся.
axes[1].set_xlim((min(n), max(n)));
#если не работает блок кода гистограммы сверху:
from pylab import*
from numpy import*
import matplotlib
import matplotlib.pyplot as plt
n = random.randn(100000)
fig, axes = plt.subplots(1, 2, figsize=(12,4))
axes[0].hist(n)
axes[0].set_title("Default histogram")
axes[0].set_xlim((min(n), max(n)))
axes[1].hist(n, cumulative=True, bins=50)
axes[1].set_title("Cumulative detaled histogram")
axes[1].set_xlim((min(n), max(n)))
show()

# надо попробовать еще построить график в стиле комиксов - в стиле xkcd: '''http://nbviewer.ipython.org/url/jakevdp.githib.com/downloads/notebooks/XKCD_plots.ipynb '''
  
#посроение няшного графика (путь программиста)
'''
labels = ['Отрицание', 'Гнев', 'Торг', 'Депрессия', 'Принятие']
text_add = [
    'У меня ничего\nне получится',
    '*ломает клавиатуру\nоб монитор',
    'Да больно\nэто мне надо',
    'Пригласили на\nинтервью',
    'Получил офер',
]
x = np.arange(len(labels))
y = np.zeros(len(labels))
x_add = []
for x_pos in x:
    x_add.append(x_pos + np.random.uniform(0.2, 0.8))
height_y = -0.2
height_add = 0.2
with plt.xkcd():
    fig, ax = plt.subplots(figsize=(10, 6), constrained_layout=True)
    plt.axis('off')
    ax.set_ylim(-2, 0.7)
    # zorder задает "главенство". Чем больше значение,
    # тем "выше" будет стоять график
    ax.axhline(0, xmin=0.05, c='deeppink', zorder=1)
    ax.scatter(x, y, s=120, c='palevioletred', zorder=2)
    ax.scatter(x, y, s=50, c='darkmagenta',zorder=4)
    ax.scatter(x, y, s=30, c='darkmagenta', zorder=3)
    # Пять стадий
    for x_pos, label in zip(x, labels):
        ax.text(x_pos, height_y, label, ha='center',
                fontsize=12, color='royalblue')
    # Вертикальные линии
    markerline, stemline, baseline = ax.stem(x_add,
                                             y + height_add,
                                             use_line_collection=True)
    plt.setp(baseline, zorder=0)
    plt.setp(markerline, marker=',', color='darkmagenta')
    plt.setp(stemline, color='darkmagenta')
    # Дополнительный текст
    for x_pos, text in zip(x_add, text_add):
        ax.text(x_pos, height_add, text, ha='center',
                fontsize=9, color='blue')
    ax.set_title('Путь программиста', fontweight='bold',
                 fontfamily='serif', fontsize=16, color='royalblue')
    # 2.18 и 0.6 наиболее приближает текст к центру
    ax.text(2.18,0.6, "Или как Data Scientist'ом",
        fontfamily='serif', fontsize=12, color='mediumblue', ha='center'
        
#(Функция axhline задает главную прямую линию, scatter необходимы для точек. Функция stem создает вертикальные линии, а устанавливают plt.setp. Данный пример показывает, что смешные рисунки могут быть сотворены в Python без помощи инструментов типа Paint. Более того, мы могли бы сделать не прямую линию, а изогнутую с помощью синусоидальной функции (numpy.sin).)

'''
###


#ключевые слова в питоне, которыми нельзя называть переменные:
'''False ;class ;finally ;is ;return ;None ;continue ;for ;lambda ;try ; True ;def ;from ;nonlocal ;while ;and ;del ;global ;not ;with ;as ;elif ;if ;or ;yield ;assert ;else ;import ;pass ;break ;except ;in ;raise.'''
#оранжевым цветом подсвечены ключевые слова, а фиолетовым- функции (в основном)

#или подсчёт среднего балла всех студентов по предмету математика для списка вида (оказывается несложно суммировать по столбцу)
'''[['Attwood', '93', '76', '80'],
 ['Babcock', '95', '52', '73'],
 ['Freeman', '71', '89', '34'],
 ['Francis', '82', '89', '84']]'''
 #пишется одной строкой:
 '''[sum([int(m) for f,m,p,l in lst]) / len(lst)]'''
 #или обработка ввода сначала количества строк, затем ввода самих строк в задаче про черепашку:
'''lst = [input().split() for i in range(int(input()))]'''
     ###
#Есть интересный вариант реализации с поворотом матрицы на 90 градусов против часовой стрелки. Программа получается компактная.

for j in range(N - 1, -1, -1):
    for i in matrix:

        print(i[j], end=" ")

    print()

#или list comprehension

matrix = [[i[j] for i in matrix] for j in range(N - 1, -1, -1)]
     ###


#
'''
Напишите простой калькулятор, который считывает с пользовательского ввода три строки: первое число, второе число и операцию, после чего применяет операцию к введённым числам ("первое число" "операция" "второе число") и выводит результат на экран.

Поддерживаемые операции: +, -, /, *, mod, pow, div, где
mod — это взятие остатка от деления,
pow — возведение в степень,
div — целочисленное деление.

Если выполняется деление и второе число равно 0, необходимо выводить строку "Деление на 0!".

Обратите внимание, что на вход программе приходят вещественные числа.
'''

# put your python code here
a = float(input('Число а калькулятора: '))
b = float(input('Число b калькулятора: '))
operation = str(input('Что нужно сделать? (введите операцию(*,/, ...)): '))
if operation == 'mod' and b != 0:
    print(float(a%b))
elif operation == 'mod' and b ==0:
    print('Деление на 0!')
if operation == 'pow':
    print(float(a**b))
if operation == 'div' and b != 0:
    print(float(a//b))
elif operation == 'div' and b == 0:
    print('Деление на 0!')
if operation == '+':
    print(float(a+b))
if operation == '-':
    print(float(a-b))
if operation == '/' and b != 0:
    print(float(a/b))
elif operation == '/' and b == 0:
    print('Деление на 0!')
if operation == '*':
    print(float(a*b))

'''
или:
first = float(input())
second = float(input())
action = input()
operations = {"mod": "%", "div": "//", "pow": "**"}
try:
    print(eval("(" + str(first) + ")" + operations.get(action, action) + str(second)))
except ZeroDivisionError:
    print('Деление на 0!')
'''
'''
или:
x = float(input())
y = float(input())
oper = input()
switcher = {
    '+': "+",
    '-': "-",
    '*': "*",
    '/': "/",
    'mod': "%",
    'div': "//",
    'pow': '**'
}
if ((x==0 or y==0) and (oper == 'mod' or oper == 'div' or oper == '/')):
    print("Деление на 0!")
else:
    print(eval(f"({x}){switcher[oper]}({y})"))
'''



'''
Жители страны Малевии часто экспериментируют с планировкой комнат. Комнаты бывают треугольные, прямоугольные и круглые. Чтобы быстро вычислять жилплощадь, требуется написать программу, на вход которой подаётся тип фигуры комнаты и соответствующие параметры, которая бы выводила площадь получившейся комнаты.
'''
# put your python code here
import math
p = 3.14
input = str(input())
if input == 'Треугольник' or 'треугольник':
    a = int(input())
    b = int(input())
    c = int(input())
    p = int(a+b+c)/2
    S = p*(p-a)*(p-b)*(p-c)
    S = math.sqrt(S)
    print(float(S))
elif input == 'Прямоугольник' or 'прямоугольник':
    a = int(input())
    b = int(input())
    print(a*b)
elif input == 'Круг' or 'круг':
    r = int(input())
    S = p *(r**2)
    print(S)
else:
    print('Введите объект из списка(Треугольник, Прямоугольник или Круг).')
#Площадь круга- S = π × r2, где r — это радиус, π — это константа, которая выражает отношение длины окружности к диаметру, она приблизительно равна 3,14.


'''
Евгений Архипов
5 лет назад
Посоветую вам прорешивать эту задачу несколькими стандартными способами, не прибегая к готовым функциям.

Для начала попробуйте написать "говно-код" в 30-100 строк, расписав каждый существующий вариант.

После этого сходите попить чайку и подумайте, как код можно оптимизировать. Уменьшите количество строк до стабильных 20-30.

Снова попейте чай и снова подумайте, как код можно оптимизировать и дойти до 10-15 строк используя стандартные методы, но иной подход алгоритма (об этом ниже). Если прибегнуть в конце к тернарным условным операциям, то можно уменьшить код и до 5 строк, используя лишь пройденный материал (переменные, инпуты, if и else).

Для оптимизации дам несколько советов:

1. Повторю других комментаторов, что любое из трёх чисел можно вычислить вычитанием из суммы всех чисел оставшихся двух: b = (a + b + c) - (a + c). Думайте, куда это можно применить.

2. Переменные можно создавать и записывать в одну строку: "x, y, z = 1, 2, 3", инпуты тоже можно так записывать: "x, y = input(), input()". Таким образом три строки кода превращаются в одну. Не перегибайте с этим, оставляйте код читаемым.

3. Вы можете попробовать пойти другим путём, не самым очевидным на первый взгляд. Например, вы можете создать переменные min и max (это переменные, не функции), равные первому введённому числа, а потом другими инпутами изменять эти значения, сравнивая их и образуя новые связи этих переменных..

4. Начните применять параметр "sep=" функции "print()", который позволяет записать print() в одну строку, а вывести на несколько.

5. Прочитайте про тернарные условные операции - это позволит вам сократить ещё немного строчек кода.

В целом, посоветую прорешивать все эти начальные задания максимальным количеством способов, чтобы выработать у себя память к различным примитивным алгоритмом. Вы ими не будете пользоваться в будущем, да, вы будете использовать готовые функции и библиотеки, но вам нужно перестроить мышление и прорешивание задач всеми возможными способами вам в этом поможет однозначно. Удачи.

---
Сергей Латин
8 лет назад
Привет всем! Решил задачу в 8 строк. Видеоматериалы я еще не смотрел, а учился по книгам. Использовал 3 переменные, конструкцию If и print(). Покажу вам пару приемов, которые сократят ваш код.

Существует такая конструкция:  a, b, c = x, y, z  , которая присваивает переменным слева от знака равно значения справа в том порядке в котором они определены. Это все равно, что a = x, b = y, c=z. Данный прием чаще используется при работе со списками, но здесь тоже прекрасно работает. Вместо x,y,z могут быть данные любого типа, даже input().

Пример  stroka, chislo, input = "Hello world!", 777,  input()

Еще данный прием используется при сортировки списков "пузырьковым методом", пример: a, b = b, a

Этот код поменяет местами значения переменных a и b.

Функция print(arg1, arg2, ..., argN) выводит аргументы через пробел. Если указать флаг sep="\n", то каждый аргумент выведется на новой строке, пример print(arg1, arg2 , sep="\n")

Надеюсь кому-то это поможет.
'''
'''
Напишите программу, которая получает на вход три целых числа, по одному числу в строке, и выводит на консоль в три строки сначала максимальное, потом минимальное, после чего оставшееся число.

На ввод могут подаваться и повторяющиеся числа.
'''
# put your python code here

a, b, c = int(input()), int(input()), int(input())
a = (a + b + c) - (b + c)
b = (a + b + c) - (a + c)
c = (a + b + c) - (a + b)
if ((a >= b and a >= c) and (b <= a and b <= c)):
    print(a)
    print(b)
    print(c)
elif ((a >= b and a >= c) and (c <= a and c <= b)):
    print(a)
    print(c)
    print(b)
elif ((b >= a and b >= c) and (c <= a and c <= b)):
    print(b)
    print(c)
    print(a)
elif ((b >= a and b >= c) and (a <= b and a <= c)):
    print(b)
    print(a)
    print(c)
elif ((c >= a and c >= b) and (a <= b and a <= c)):
    print(c)
    print(a)
    print(b)
elif ((c >= a and c >= b) and (b <= a and b <= c)):
    print(c)
    print(b)
    print(a)
    

'''or:
x = int(input())
y = int(input())
z = int(input())
a = min(x, y, z)
b = max(x, y, z)
c = x + y + z - a - b
print(b)
print(a)
print(c)

or:
x = [int(input()) for i in range(3)]
print(max(x),"\n", min(x),"\n", sum(x) - max(x) - min(x))

or:
print("{2}\n{0}\n{1}".format(*sorted([int(input()) for i in range(3)])))

or:
l = list(map(int, (input() for i in range(3))))

print(max(l))
l.remove(max(l))

print(min(l))
l.remove(min(l))

print(l[0])
'''
'''
После курса по С++ это задание сделал меньше, чем за 5 минут.

Если вторая с конца цифра 1, то всегда -ов

Иначе если последняя цифра 0, 5-9, то -ов;  если 1, то -ст; если 2-4, то -ста

Получить вторую с конца цифру: (n % 100) // 10

Получить последнюю: n % 10
if number in (2, 3, 4)
Советы:
1) Напишите на листе три колонки: Программист, Программиста, Программистов. Для каждого столбца напишите правило, когда число читается именно так. Например: Программист - %1, но не %11
2) Я использовал остаток от деления на 10 и 100 и писал их в разные переменные. Когда нужно использовал их.
3) Программист и Программиста - две самые маленькие группы +- пару исключений. Их проще описать в if и elif. А большинство случаев Программистов проще не описывать, а оставь в конце кода под else.
Успехов!

'''
'''
 институте биоинформатики по офису передвигается робот. Недавно студенты из группы программистов написали для него программу, по которой робот, когда заходит в комнату, считает количество программистов в ней и произносит его вслух: "n программистов".

Для того, чтобы это звучало правильно, для каждого
�
n нужно использовать верное окончание слова.

Напишите программу, считывающую с пользовательского ввода целое число
�
n (неотрицательное), выводящее это число в консоль вместе с правильным образом изменённым словом "программист", для того, чтобы робот мог нормально общаться с людьми, например: 1 программист, 2 программиста, 5 программистов.

В комнате может быть очень много программистов. Проверьте, что ваша программа правильно обработает все случаи, как минимум до 1000 человек.

Дополнительный комментарий к условию:
Обратите внимание, что задача не так проста, как кажется на первый взгляд. Если ваше решение не проходит какой-то тест, это значит, что вы не рассмотрели какой-то из случаев входных данных (число программистов
0
≤
�
≤
1000
0≤n≤1000). Обязательно проверяйте свои решения на дополнительных значениях, а не только на тех, что приведены в условии задания.

Так как задание повышенной сложности, вручную код решений проверяться не будет. Если вы столкнулись с ошибкой в первых четырёх тестах, проверьте, что вы используете только русские символы для ответа. В остальных случаях ищите ошибку в логике работы программы.
'''
student = int(input())
progger = 'программист'
formula_a = (student%100)//10
formula_b = student % 10
if formula_a == 1:
    print(student, progger+'ов')
elif formula_b == 0 or 5 <= formula_b <= 9:
    print(student, progger+'ов')
elif 2 <= formula_b <= 4:
    print(student, progger+'а')
else:
    print(student, progger)
    
    
    
'''
Паша очень любит кататься на общественном транспорте, а получая билет, сразу проверяет, счастливый ли ему попался. Билет считается счастливым, если сумма первых трех цифр совпадает с суммой последних трех цифр номера билета.

Однако Паша очень плохо считает в уме, поэтому попросил вас написать программу, которая проверит равенство сумм и выведет "Счастливый", если суммы совпадают, и "Обычный", если суммы различны.

На вход программе подаётся строка из шести цифр.
'''
# put your python code here
x = int(input())
y = x//100000+x%10000//1000+x%100000//10000 #последние три цифры
z = x%10+x%100//10+x%1000//100              #первые три цифры
if y == z:
    print('Счастливый')
else:
    print('Обычный')
'''or:
a, b, c, d, e, f= input()
x = int(a)+int(b)+int(c)
y = int(d)+int(e)+int(f)
if x == y:
    print('Счастливый')
else:
    print('Обычный')
'''
 
 
 '''
 В Институте биоинформатики между информатиками и биологами устраивается соревнование. Победителям соревнования достанется большой и вкусный пирог. В команде биологов a человек, а в команде информатиков — b человек.
Нужно заранее разрезать пирог таким образом, чтобы можно было раздать кусочки пирога любой команде, выигравшей соревнование, при этом каждому участнику этой команды должно достаться одинаковое число кусочков пирога. И так как не хочется резать пирог на слишком мелкие кусочки, нужно найти минимальное подходящее число.
Напишите программу, которая помогает найти это число.
Программа должна считывать размеры команд (два положительных целых числа a и b, каждое число вводится на отдельной строке) и выводить наименьшее число d, которое делится на оба этих числа без остатка.
 '''
 # put your python code here
a = int(input())
b = int(input())
d = a
while d%b:
    d+=a
print(d)
'''or
a = int (input ())
b = int (input ())

for i in range (a*b):
    i+=1
    if i%a==0 and i%b==0:
        print ('Минимальное количество кусочков = ', i)
        break
'''

#Напишите программу, которая считывает со стандартного ввода целые числа, по одному числу в строке, и после первого введенного нуля выводит сумму полученных на вход чисел.

a = int(input())
x = 0
while a!=0:
    x += a
    a =int(input())
print(x)



'''Напишите программу, на вход которой даются четыре числа a, b, c и d, каждое в своей строке. Программа должна вывести фрагмент таблицы умножения для всех чисел отрезка [a;b] на все числа отрезка [c;d].

Числа a, b, c и d являются натуральными и не превосходят 10, ≤a≤b, ≤c≤d.

Следуйте формату вывода из примера, для разделения элементов внутри строки используйте '\t' — символ табуляции. Заметьте, что левым столбцом и верхней строкой выводятся сами числа из заданных отрезков — заголовочные столбец и строка таблицы.'''
a = int(input())
b = int(input())
c = int(input())
d = int(input())
if (a and b) <= 10 >= (c and d):
    for x in range(c,d+1):
        print('\t' + str(x), end ='')
    print(end='\n')
    for y in range (a,b+1):
        print(str(y)+'\t', end='')
        for z in range (c,d+1):
            print(str(y*z)+'\t', end='')
        print(end = '\n')



'''Напишите программу, на вход которой подаётся список чисел одной строкой. Программа должна для каждого элемента этого списка вывести сумму двух его соседей. Для элементов списка, являющихся крайними, одним из соседей считается элемент, находящий на противоположном конце этого списка. Например, если на вход подаётся список [1 3 5 6 10], то на выход ожидается список [13 6 9 15 7](без кавычек). Если на вход пришло только одно число, надо вывести его же. Вывод должен содержать одну строку с числами нового списка, разделёнными пробелом.
Sample Input  1:  1 3 5 6 10
Sample Output 1:  13 6 9 15 7
'''
a = [int(i) for i in input().split()]
b = []
c = len(a)-1
d = 0
i = 0
if len(a) == 0:
    print(str(a))
else:
    for aa in a:
        if len(a)>1:
            if i == 0:
                d = a[i+1] + a[-1]
                b.append(d)
            elif i>0 and i<c:
                d = a[i-1] + a[i+1]
                b.append(d)
            elif i == c:
                d = a[i-1] + a[0]
                b.append(d)
        elif len(a) == 1:
            d = a[i]
            b.append(d)
        i += 1
    x = 0
    for aa in b:
        print(str(b[x]),' ',end='')
        x += 1
 
 
 
''' Напишите программу, которая принимает на вход список чисел в одной строке и выводит на экран в одну строку значения, которые встречаются в нём более одного раза.
Для решения задачи может пригодиться метод sort списка.
Выводимые числа не должны повторяться, порядок их вывода может быть произвольным.
Example:
Sample Input  1:  4 8 0 3 4 2 0 3
Sample Output 1:  0 3 4 (эти числа встречаются более 1 раза).
'''
s = [int(i) for i in input().split()] #читаем строку, разбиваем на части и каждую часть преобразовываем в число.
t = []
s.sort()
l = len(s)-1
k = 100000
if l != 0:
    for i in range (0, l):
        if s[i] == s[i+1] and s[i] != k:
            t.append(s[i])
            k = s[i]
    for j in range (l, l+1):
        if s[-1] == s[-2] and s[-1] != k:
            t.append(s[-1])
            k = s[-1]
ll = len(t)
for z in range (0, ll):
    print(t[z], end = ' ')


#list comprehension:
A = [1, 2, 3, 4, 5, 7, 9, 12, 14, 15, 2]
B = [0 if x < 0 else x**2 for x in A if x%2 == 0] #сразу же и отбор числа, и проверка его на деление нацело, и возведение в степень, и добавление в список В

#Документ-строка в функции:
 '''
 
 def (параметры функции):
 """ Текст-инструкция к данной функции, способная помочь в будущем для других разработчиков, содержащая в себе важную информацию, что это такое и на что она способна
 """ #завершение документ-строки. Желательно на каждой строке писать новое предложение, желательно так же писать инструкцию на двух языках: русский и английский.
    ---тело функции---
'''

'''def max2(x,y):
  if x>y:
      return x
  return y
def max3(x,y,z):
  return max2(x, max2(y, z))
max3(65,49,85)'''


'''Проверка текста на Палиндром(с начала и с конца читается одинаково), напр: ABCDCBA
a = input()
x = 0
y = len (a) - 1
is_palindrom = True
for i in a:
  if a[x] == a[y]:
    is_palindrom = True
    x += 1
    y -= 1
  elif a[x] != a[y]:
    is_palindrom = False
    x += 1
    y -= 1
if is_palindrom == True:
  print('Is palindrom')
elif is_palindrom == False:
  print('Not palindrom')
'''


#Питон позволяет сокращать кол-во текста в некоторых случаях, напр-p:
# a = True
# if a:   #if True:

#Ctrl/Command + V = Vipectus(лат) = вставить  (как переводится комманда Command+V) (С англ. вставить - insert)

# x = 0,1 ; x² = 0,01 .


'''
    if A == A_sorted:
        print('OK')
    else:
        print('Failed')
        
    Целых 4 строки в данном случае можно заменить на 1 строку:
    print('Ok' if A == A_sorted else 'Failed')    #'тернарный' условный оператор
'''

    '''
Создание списка путем range:
    A = list(range(10, 20))  # A = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
Конкатенация списков:
    A = list(range(10, 20)) + lest(range(0, 10))  #списки можно таким образом конкатенировать(складывать) друг с другом.
    # A = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Сортировка списков:
    A = list(range(10, 20)) + lest(range(0, 10))
    A.sort()
    print(A)  #A = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
    '''

       '''
Метод flush() синхронизирует текущее состояние сессии с базой данных. Это означает, что все изменения, которые были сделаны в сессии (например, добавление или удаление объектов), будут переданы в базу данных.
Sep в python- sep позволяет задать разделитель, который будет выводиться между элементами, переданными в функцию print(). По умолчанию разделителем является пробел, но с помощью sep пробел можно заменить на другой разделитель, к примеру, на запятую.
       '''

'''
    Вставка элемента в список:
    A = ['Olga', 'Masha', 'Sergey', 'Fedor']
    A.insert(1, 'Oleg')  #в параметрах(в скобках) функции insert сначала указывается индекс, куда нужно вставить элемент, а затем и сам элемент, в то же время остальные элементы списка смещаются вправо, а длина списка увеличивается на количество вставляемых элементов. Функция append() позволяет добавить элемент в конец списка. список.append('элемент')
    print(A)  #['Olga', 'Oleg', 'Masha', 'Sergey', 'Fedor']
Для python- строка - это список элементов:
    students = ['Ivan', 'Masha', 'Sasha']
    students += ['Olga']
    students += 'Olga' #Для python- строка - это список элементов.
    print(students)  #['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a'] - Ольгу расчленили...
'''

   '''
   Функция remove в списках:
   название_списка.remove('элемент, который хотим удалить')
   Причем если одноименных эл-тов несколько- функция удаляет первый такой элемент(удаляет только первое вхождение)
   students = ['Masha', 'Sasha', 'Lana', 'Olga']
   students.remove('Masha')
   print(students)  #['Sasha', 'Lana', 'Olga']
   
   Функция del в списках:
   del students[0]  # -'Sasha'
   print(students)  #['Lana', 'Olga']
   
   Получение индекса элемента в списке:
   название_списка.index('название искомого элемента')
   ind = students.index('Ann')
   print(ind) #ValueError: 'Ann' is not in list (Если элемент отсутствует- будет ошибка, иначе- выведется индекс)
   
   Наличие элемента так же можно проверить через if ... in ... : ; if ... not in ... :
   '''

      '''
   Сортировка списка:
   Не изменяя изначального порядка:
      students = ['Masha', 'Sasha', 'Lana', 'Olga']
      ordered_students = sorted(students)
      print(ordered_students)  #['Lana', 'Masha', 'Olga', 'Sasha'] - Временное изменение порядка
   Изменяя порядок списка:
   ordered_students = students.sort
   print(ordered_students)  #['Lana', 'Masha', 'Olga', 'Sasha']
   min(); max() - позволяют найти минимальное и максимальное значение в списке
   Правило: Для сортировки эл-тов списка, все эл-ты должны быть равнозначны(либо все цифры, либо все буквы/строки).
 
   Для списка в обратном порядке:
         students = ['Masha', 'Sasha', 'Lana', 'Olga']
         students.reverse() #['Olga', 'Lana', 'Sasha', 'Masha']
         или students[::-1] - метод слайсинга
         или reversed(students) - не изменяет изначальный список
      '''
    
''' Генерация списков:
    a = [0] * 5  #[0, 0, 0, 0, 0]
    List comprehension:
    a = [0 for i in range(5)]  #[0, 0, 0, 0, 0]
    a = [i*i for i in range(5)]  #[0, 1, 4, 9, 16]
    a = [int(i) for i in input().split()] - считывание элементов, добавление в список, преобразование в целочисл. знач. и разделение
'''
  
#Для того, чтобы развернуть что-то (список, функцию, кортежа и тд), можно воспользоваться '*':
#L = [1, 2, 3, 4, 5]
#print(*L)  - 1, 2, 3, 4, 5
#

#Способ сокращения строк:
'''Рекурсия:                                         #В рекурсии есть рекуррентный и крайний случаи (способ обработки и крайнее знач.).
import grapghics as gr
window = gr.GraphWin('Russian game', 600, 600)
alpha = 0,2 #общепринятое значение alpha. 0.2 == 1/5
def fractal_rectangle(A, B, C, D, deep = 10):
    if deep < 1:
        return
    #Вместо:
    gr.Line(gr.Point(*A), gr.Point(*B).draw(window))
    gr.Line(gr.Point(*B), gr.Point(*C).draw(window))
    gr.Line(gr.Point(*C), gr.Point(*D).draw(window))
    gr.Line(gr.Point(*D), gr.Point(*A).draw(window))

    #Можно смело написать:
    for M, N in (A, B), (B, C), (C, D), (D, A):          #Можно в квадратные скобки оформить четыре пары скобок но необяз-но.
        gr.Line(gr.Point(*M), gr.Point(*N).draw(window)) #Можно двумя переменными пробежаться по кортежу.

    A1 = (A[0]*(1-aplha) + B[0]*alpha, A[1]*(1-aplha) + B[1]*alpha)
    B1 = (B[0]*(1-aplha) + C[0]*alpha, B[1]*(1-aplha) + C[1]*alpha)
    C1 = (C[0]*(1-aplha) + D[0]*alpha, C[1]*(1-aplha) + D[1]*alpha)
    D1 = (D[0]*(1-aplha) + A[0]*alpha, D[1]*(1-aplha) + A[1]*alpha)
'''

   '''
   assert - оператор, с англ- assertion-утверждение.
   Факториал:
   n! = (n-1)! * n
   
   Типизация в питоне происходит сл. обр., посредством ':' :
   def ... (a:int, b : int, c : str):
       ... (Типизация необязательна. В питоне она автоматическая. Она нужна как комментарий, для ясности)
       
   '''

      '''
      Алгоритм Евклида:  (НОД Наибольший Общий Делитель) (gcd = Greatest common divisor(НОД))
    def gcd(a,b):
        if a == b:
            return a
        elif a > b:
            return gcd(a-b, b)
        else: #a<b
            return gcd(a, b-a)
      
      Или короче:
      def gcd(a, b):
          if b == 0:
              return a
          else:
              return gcd(b, a%b)
      
      Еще короче:
      def gcd (a, b):
      return (a if b == 0 else gcd(b, a%b))
      '''
      
'''
Быстрое возведение в степень:

def pow(a:float,n:int):  #сначала число, а затем требуемая степень
    if n == 0:
        return 1
    elif n%2 == 1: #Для нечетных
        return pow (a, n-1)*a
    else:  #Для n-четных
        return pow(a**2, n//2)
'''



   '''
   Генерация системы счислений:
   
   def gen_bin(M, prefix=''):
        if M == 0:
            print(prefix)
        else:                        #for digit in '0','1':
            gen_bin(M-1, prefix+'0') #M-1, prefix + digit
            gen_bin(M-1, prefix+'1')
def generate_number(N:int, M:int, prefix=None):
    """Генерирует все числа (с лидирующими незначащими нулями) в N-ричной системе счисления (N<=10) длины M)
    """
    prefix = prefix or []
    if M == 0:
        print(prefix)
        return
    for digit in range(N):
        prefix.append(digit)
        generate_number(N, M-1, prefix)
        prefix.pop()
        
    gen_bin(3)  #только для двоичной СС
    generate_number(4,3)  #для произвольной СС
   '''

#генерация перестановок чисел:
def find(number, A):
    ''' Ищет number в А и возвращает True, если такой есть, или False- если таковой нашелся
    '''
    for x in A:
        if number == x:
            return True
    return False
    
def generate_permutations(N:int, M:int=-1, prefix=None):
    '''Генерация всех перестановок N чисел в M позициях, с префиксом prefix
    '''
    M = N if M == -1 else M  # по умолчанию N чисел в N позициях
    prefix = prefix or []
    if M == 0:
        print(prefix)
        return
    for number in range(1,N+1):
        if find (number, prefix):
            continue
        prefix.append(number)
        generate_permutations(N, M-1, prefix)
        prefix.pop()

generate_permutations(3)


#программка, позволяющая вывести матричную спираль по часовой стрелке:
def spiral(n):
    dx, dy = 1, 0
    x, y = 0, 0
    myarray = [[None] * n for j in range(n)]
    for i in range(1, n**2 + 1):
        myarray[x][y] = i
        nx, ny = x + dx, y + dy
        if 0<=nx<n and 0<=ny<n and myarray[nx][ny] == None:
            x, y = nx, ny
        else:
            dx, dy = -dy, dx
            x, y = x+dx, y+dy
    return myarray
def printspiral(myarray):
    n = range(len(myarray))
    for y in n:
        for x in n:
            print(myarray[x][y], end = ' ')
        print()
n = int(input())
printspiral(spiral(n))

#работка со списком:
mylst = [x if x % 2 == 0 else "odd" for x in range(20)]
print(mylst)
result : [0, 'odd', 2, 'odd', 4, 'odd', 6, 'odd', 8, 'odd', 10, 'odd', 12, 'odd', 14, 'odd', 16, 'odd', 18, 'odd']



'''Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк. После последней строки матрицы идёт строка, содержащая только строку "end" (без кавычек, см. Sample Input).

Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции i, j равен сумме элементов первой матрицы на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). У крайних символов соседний элемент находится с противоположной стороны матрицы.

В случае одной строки/столбца элемент сам себе является соседом по соответствующему направлению:
'''
# put your python code here
n = ''
m = []
while True:
    n = str(input()) # ввод строк
    if n == 'end':
        break
    m.append([int(s) for s in n.split()])
li, lj = len(m), len(m[0])
new = [[sum([m[i-1][j], m[(i+1)%li][j], m[i][j-1], m[i][(j+1)%lj]]) for j in range(lj)] for i in range(li)]

for i in range (li):
    for j in range (lj):
        print(new[i][j], end =' ')
    print()


'''
Напишите функцию f(x), которая возвращает значение следующей функции, определённой на всей числовой прямой:
     ⎧  1 − (x + 2) ** 2,  при x ≤ -2;
f(x)=⎨  -x / 2,  при -2 < x ≤ 2;
     ⎩  ((x - 2) ** 2) + 1,  при 2 < x.
Требуется реализовать только функцию, решение не должно осуществлять операций ввода-вывода.
'''
def f(x):
    summ = 0
    if x <= -2:
        summ = (1 -(x+2)**2)
    elif -2 < x <= 2:
        summ = -(x/2)
    elif 2 < x:
        summ = ((x - 2)**2) + 1
    return summ
f(4.5)


'''Напишите функцию modify_list(l), которая принимает на вход список целых чисел, удаляет из него все нечётные значения, а чётные нацело делит на два. Функция не должна ничего возвращать, требуется только изменение переданного списка, например:'''

lst = [1, 2, 3, 4, 5, 6]
print(modify_list(lst))  # None
print(lst)               # [1, 2, 3]
modify_list(lst)
print(lst)               # [1]
lst = [10, 5, 8, 3]
modify_list(lst)
print(lst)               # [5, 4]
#сам код:
def modify_list(lst):
    global l
    l = [i // 2 for i in lst if i % 2 == 0]
#при выполнении нужно все, что написано после 'например:' и до '#сам код' - написать снизу тела функции- тогда код сработает.




'''Напишите функцию update_dictionary(d, key, value), которая принимает на вход словарь d и два числа: key и value.

Если ключ key есть в словаре d, то добавьте значение value в список, который хранится по этому ключу.
Если ключа key нет в словаре, то нужно добавить значение по ключу 2⋅key.
Если и ключа 2⋅key нет, то нужно добавить ключ 2⋅key в словарь и сопоставить ему список из переданного элемента [value].

Требуется реализовать только эту функцию, кода вне неё не должно быть.
Функция не должна вызывать внутри себя функции input и print.

Пример работы функции:
d = {}
print(update_dictionary(d, 1, -1))  # None
print(d)                            # {2: [-1]}
update_dictionary(d, 2, -2)
print(d)                            # {2: [-1, -2]}
update_dictionary(d, 1, -3)
print(d)                            # {2: [-1, -2, -3]}'''

# Вариант №1:
# не добавляйте кода вне функции
def update_dictionary(d, key, value):
    # put your python code here
    if key in d:
        d[key].append(value)
        #print('ключ есть')
    elif key is not d:
        #d[2*key]=[]
        if 2*key is d:
            d[2*key].append(value)
            #print('ключ 2*key уже есть')
        elif (2*key is not d) and d.get(2*key)==None:
            d[2*key]=[]
            d[2*key].append(value)
            #print('создание ключа и + новое значение списка')
        elif (2*key is not d) and d.get(2*key)!=None:
            d[2*key].append(value)
            #print('создание ключа и + значение списка')
    return

# не добавляйте кода вне функции

# Вариант №2(лично мною продуманный):
def update_dictionary(d, key, value):
    if key in d:
        d[key].append(value)
    elif key not in d:
        if (key*2) in d:
            d[key*2].append(value)
        elif (key*2) not in d:
            d[key*2] = []
            d[key*2].append(value)
            #d[key*2] += [value]
    return


'''
Когда Антон прочитал «Войну и мир», ему стало интересно, сколько слов и в каком количестве используется в этой книге.

Помогите Антону написать упрощённую версию такой программы, которая сможет подсчитать слова, разделённые пробелом и вывести получившуюся статистику.

Программа должна считывать одну строку со стандартного ввода и выводить для каждого уникального слова в этой строке число его повторений (без учёта регистра) в формате "слово количество" (см. пример вывода).
Порядок вывода слов может быть произвольным, каждое уникальное слово﻿ должно выводиться только один раз.

Sample Input 1:
a aa abC aa ac abc bcd a

Sample Output 1:
a 2
aa 2
ac 1
abc 2
bcd 1
'''
# put your python code here
n='' #инициализация строки
n = str(input())
m = [] #инициализация списка
m.append([str(s.lower()) for s in n.split()])
d = {} #инициализация пустого словаря
li, lj = len(m), len(m[0])
for i in range(li):
    for j in range(lj):
        p = m[i][j]
        if p in d:
            d[p]+=1
        else:
            d[p] = 1
for key,value in d.items():
   print(key,value)


'''
Имеется реализованная функция f(x), принимающая на вход целое число x,
которая вычисляет некоторое целочисленое значение и возвращает его в качестве результата работы.

Функция вычисляется достаточно долго, ничего не выводит на экран,
не пишет в файлы и зависит только от переданного аргумента x.

Напишите программу, которой на вход в первой строке подаётся число
n — количество значений x, для которых требуется узнать значение
функции f(x), после чего сами эти n значений, каждое на отдельной
строке. Программа должна после каждого введённого значения аргумента
вывести соответствующие значения функции f на отдельной строке.

Для ускорения вычисления необходимо сохранять уже вычисленные значения
функции при известных аргументах.

Обратите внимание, что в этой задаче установлено достаточно сильное
ограничение в две секунды по времени исполнения кода на тесте.

 Sample Input:
5
5
12
9
20
12
Sample Output:
11
41
47
61
41 '''
# Считайте, что функция f(x) уже определена выше. Определять её отдельно не требуется.
n = int(input())
o= []
d = {}
for i in range(n):
    g = int(input())
    o.append(g)
for j in range(0, len(o)):
    key = o[j]
    if key in d:
        print(d[key])
    elif key not in d:
        p = o[j]
        d[key] = f(p)
        print(d.get(key))

# [STEPIK]
# Программирование на Python https://stepik.org/67
# 03_07_01 Задачи по материалам недели

'''
Напишите программу, которая принимает на стандартный вход список игр футбольных команд с результатом матча и выводит на стандартный вывод сводную таблицу результатов всех матчей.

За победу команде начисляется 3 очка, за поражение — 0, за ничью — 1.

Формат ввода следующий:
В первой строке указано целое число n — количество завершенных игр.
После этого идет n строк, в которых записаны результаты игры в следующем формате:
Первая_команда;Забито_первой_командой;Вторая_команда;Забито_второй_командой

Вывод программы необходимо оформить следующим образом:
Команда:Всего_игр Побед Ничьих Поражений Всего_очков

Конкретный пример ввода-вывода приведён ниже.

Порядок вывода команд произвольный.

Sample Input:
3
Зенит;3;Спартак;1
Спартак;1;ЦСКА;1
ЦСКА;0;Зенит;2
Sample Output:
Зенит:2 2 0 0 6
ЦСКА:2 0 1 1 1
Спартак:2 0 1 1 1
'''

'''n = int(input())

teams = {}
games = 1
wins = 0
draws = 0
loses = 0
points = 0
#team_list = [games, wins, draws, loses, points]

i = 0

for _ in range(n):
    
    string = input().split(';')
    
    # Проверка наличия команд из ввода в словаре
    # если нет, добавляем
    # если есть, увеличиваем количество игр на 1
    
    # Проверка наличия первой команды из ввода в словаре
    if string[i] not in teams:
        teams[string[i]] = [games, wins, draws, loses, points]
    elif string[i] in teams:
        teams[string[i]][0] += 1
        
    # Проверка наличия второй команды из ввода в словаре
    if string[i+2] not in teams:
        teams[string[i+2]] = [games, wins, draws, loses, points]
    elif string[i+2] in teams:
        teams[string[i+2]][0] += 1
        
    # Проверка результатов матча
    
    if string[i+1] > string[i+3]:
        teams[string[i]][1] += 1     # Начисление победы для К1
        teams[string[i]][4] += 3     # Начисление очков победы для К1
        teams[string[i+2]][3] += 1   # Начисление поражения для К2
        teams[string[i+2]][4] += 0   # Начисление очков поражения для К2
    elif string[i+1] < string[i+3]:
        teams[string[i+2]][1] += 1   # Начисление победы для К2
        teams[string[i+2]][4] += 3   # Начисление очков победы для К2
        teams[string[i]][3] += 1     # Начисление поражения для К1
        teams[string[i]][4] += 0     # Начисление очков поражения для К1
    elif string[i+1] == string[i+3]:
        teams[string[i]][2] += 1   # Начисление ничьей для К1
        teams[string[i]][4] += 1   # Начисление очков ничьей для К1
        teams[string[i+2]][2] += 1     # Начисление ничьей для К2
        teams[string[i+2]][4] += 1     # Начисление очков ничьей для К2

for key, value in teams.items():
    row = key + ':' + ' ' + str(value[0]) + ' ' + str(value[1]) + ' ' + str(value[2]) + ' ' + str(value[3]) + ' ' + str(value[4])
    print(row)'''

###
'''
    Напишите программу, которая принимает на стандартный вход список игр футбольных команд с результатом матча и выводит на стандартный вывод сводную таблицу результатов всех матчей.

За победу команде начисляется 3 очка, за поражение — 0, за ничью — 1.

Формат ввода следующий:
В первой строке указано целое число nn — количество завершенных игр.
После этого идет nn строк, в которых записаны результаты игры в следующем формате:
Первая_команда;Забито_первой_командой;Вторая_команда;Забито_второй_командой

Вывод программы необходимо оформить следующим образом:
Команда:Всего_игр Побед Ничьих Поражений Всего_очков

Конкретный пример ввода-вывода приведён ниже.

Порядок вывода команд произвольный.
3
Спартак;9;Зенит;10
Локомотив;12;Зенит;3
Спартак;8;Локомотив;15 :
'''
n = int(input())
x_list = [input().split(';') for x in range(n)]
vs = [(x[0], x[2]) for x in x_list]
import itertools
clubs = set(itertools.chain.from_iterable(vs))
res = {club:[0, 0, 0, 0, 0] for club in clubs}
for kom1, gol1, kom2, gol2 in x_list:
    res[kom1][0] += 1
    res[kom2][0] += 1
    if int(gol1) > int(gol2):
        res[kom1][1] += 1
        res[kom1][4] += 3
        res[kom2][3] += 1
    elif int(gol1) < int(gol2):
        res[kom2][1] += 1
        res[kom2][4] += 3
        res[kom1][3] += 1
    elif int(gol1) == int(gol2):
        res[kom1][2] += 1
        res[kom1][4] += 1
        res[kom2][2] += 1
        res[kom2][4] += 1
for club in clubs:
    print('{}:{}'.format(club, ' '.join(map(str, res[club]))))  #Спартак:2 0 0 2 0
                                                                #Локомотив:2 2 0 0 6
                                                                #Зенит:2 1 0 1 3

'''Простейшая система проверки орфографии может быть основана на использовании списка известных слов.
Если введённое слово не найдено в этом списке, оно помечается как "ошибка".
Попробуем написать подобную систему.
На вход программе первой строкой передаётся количество d известных нам слов, после чего на d строках указываются эти слова. Затем передаётся количество l строк текста для проверки, после чего l строк текста.
Выведите уникальные "ошибки" в произвольном порядке. Работу производите без учёта регистра.
    Sample Input:
4
champions
we
are
Stepik
3
We are the champignons
We Are The Champions
Stepic
    Sample Output:
stepic
champignons
the'''

known_words = set(input().lower() for _ in range(int(input())))
text = [input().lower().split() for _ in range(int(input()))]
errors = {word for sentence in text for word in sentence if word not in known_words}
print(*errors, sep='\n')


'''В какой-то момент в Институте биоинформатики биологи перестали понимать, что говорят информатики: они говорили каким-то странным набором звуков.
В какой-то момент один из биологов раскрыл секрет информатиков: они использовали при общении подстановочный шифр, т.е. заменяли каждый символ исходного сообщения на соответствующий ему другой символ. Биологи раздобыли ключ к шифру и теперь нуждаются в помощи:
Напишите программу, которая умеет шифровать и расшифровывать шифр подстановки. Программа принимает на вход две строки одинаковой длины, на первой строке записаны символы исходного алфавита, на второй строке — символы конечного алфавита, после чего идёт строка, которую нужно зашифровать переданным ключом, и ещё одна строка, которую нужно расшифровать.

Пусть, например, на вход программе передано:
    abcd
    *d%#
    abacabadaba
    #*%*d*%

Это значит, что символ a исходного сообщения заменяется на символ * в шифре, b заменяется на d, c — на % и d — на #.
Нужно зашифровать строку abacabadaba и расшифровать строку #*%*d*% с помощью этого шифра. Получаем следующие строки, которые и передаём на вывод программы:
    *d*%*d*#*d*
    dacabac'''
    def encrypt_substitution_cipher(alphabet, cipher_alphabet, message):
    encryption_key = str.maketrans(alphabet, cipher_alphabet)
    return message.translate(encryption_key)

def decrypt_substitution_cipher(alphabet, cipher_alphabet, message):
    decryption_key = str.maketrans(cipher_alphabet, alphabet)
    return message.translate(decryption_key)

alphabet = input()
cipher_alphabet = input()
to_encrypt = input()
to_decrypt = input()

print(encrypt_substitution_cipher(alphabet, cipher_alphabet, to_encrypt))
print(decrypt_substitution_cipher(alphabet, cipher_alphabet, to_decrypt))


'''
Группа биологов в институте биоинформатики завела себе черепашку.
После дрессировки черепашка научилась понимать и запоминать указания биологов следующего вида:
север 10
запад 20
юг 30
восток 40
где первое слово — это направление, в котором должна двигаться черепашка, а число после слова — это положительное расстояние в сантиметрах, которое должна пройти черепашка.
Но команды даются быстро, а черепашка ползёт медленно, и программисты догадались, что можно написать программу, которая определит, куда в итоге биологи приведут черепашку. Для этого программисты просят вас написать программу, которая выведет точку, в которой окажется черепашка после всех команд. Для простоты они решили считать, что движение начинается в точке (0, 0), и движение на восток увеличивает первую координату, а на север — вторую.
Программе подаётся на вход число команд n, которые нужно выполнить черепашке, после чего n строк с самими командами. Вывести нужно двf
числа в одну строку: первую и вторую координату конечной точки черепашки. Все координаты целочисленные.
    Sample Input:
4
север 10
запад 20
юг 30
восток 40
    Sample Output:
20 -20
'''
a = int(input())
x, y = 0, 0
for _ in range(a):
    where, cm = input().split()
    cm = int(cm)
    if where == 'север':
        y += cm
    elif where == 'запад':
        x -= cm
    elif where == 'юг':
        y -= cm
    elif where == 'восток':
        x += cm
print(x, y)


'''может кому интересно где вы всё время решали задачки)
print(platform.node(),'\n') #отобажает имя в сети
print(platform.python_version(),'\n') #версия питона
print(platform.machine(),'\n')  #тип машины
print(platform.system(),'\n')   #имя системы
print(platform.processor(),'\n') #имя процессора - не отображает
print(platform.python_build(),'\n') #номер сборки python и дату создания
print(platform.python_compiler(),'\n') #идентификатор компилятора
print(platform.python_branch(),'\n') #идентификатор SCM реализации python
print(platform.python_implementation(),'\n') #идентификатор реализации python
print(platform.python_revision(),'\n') #версия SCM реализации
print(platform.version(),'\n') #версия python в виде строки 'major.minor.patchlevel'
print(platform.uname(),'\n') #возвращает все вместе system,node,release,version,,machine,processor
print(platform.release(),'\n') #выпуск системы
print(platform.platform(),'\n') #идентификатор базовой платформы
'''

